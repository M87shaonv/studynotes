# Linux基础

在Linux中，挂载点指的是一个目录，用于将一个文件系统连接到Linux的目录结构中。当在Linux中添加一个新的硬盘分区或其他存储设备时，需要将它挂载到一个已经存在的目录上，这个目录就是挂载点

设备类型

1. 标准分区
2. LVM：可以弹性增加/削减文件系统容量的设备设置
3. LVM简单配置：使用多少容量才分配多少磁盘容量

文件类型

1. ext2/ext3/ext4：Linux早期适用的文件系统类型，ext3/ext4文件系统多了日志的记录， 对于系统的复原比较快速，近来比较少使用ext4
2. swap：交换分区，就是把磁盘充当为内存使用，swap不会使用到目录树的挂载，因此无需指定挂载点
3. BIOS Boot：是一个特殊的分区，它不包含文件系统，只用于存储引导加载程序所需的代码。它的作用是在使用BIOS引导方式的系统中，为引导加载程序提供一个额外的空间
4. xfs：这个是目前CentOS默认的文件系统，对于 大容量的磁盘管理非常好，而且格式化的时候速度相当快
5. vfat：同时被Linux与Windows所支持的文件系统类型。如果你的主机硬盘内同时存在 Windows与Linux操作系统，为了数据的交换， 确实可以创建一个vfat的文件系统

在Linux中，**只要文件名是以小数点开头就是隐藏文件**

Linux默认的情况下会提供六个Terminal来让使用者登陆， 切换的方式是使用：[Ctrl] + [Alt] + [F1] ~ [F6]的组合按钮

系统会将[F1] ~ [F6]命名为tty1 ~ tty6的操作接口环境，如果安装的是图形界面，那么tty1就是图形接口界面

`exit`是登出Linux，但不是关机，，Linux本身已经有相当多的工作在进行，登陆仅是其中的一个工作， 所以当离开时，这次这个登陆的工作就停止了，但此时Linux其他的工作还是继续在进行

+ [Enter]代表着一行指令的开始启动，指令太长的时候，可以使用反斜线 **\\** 来跳脱[Enter]符号，使指令连续到下一行

+ Linux区分大小写，输入指令要注意

+ 几乎所有命令在后面加上 `--help`就能得到这个指令的基本用法与选项参数

+ 在指令前面加上man(manual操作说明)是一个更丰富的求助系统

  左上角第一行数字的含义：

  ![image-20240110160503296](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240110160503296.png)

  上述的表格内容可以使用`man man`来更详细的取得说明

  可以使用 `/ 字符或字符串`来向下搜寻匹配的字符串，`?`是向上搜寻

  使用 `n,N`来分别继续向上和向下的下一个搜寻

+ 另一种page：`info page`

  与man的用途其实差不多，都是用来查询指令的用法或者是文件的格式

  与man page一口气输出一堆信息不同的是，info page则是将文件数据拆成一个一个的段落，每个段落用自己的页面来撰写， 并且在各个页面中有类似网页的超链接来跳到各不同的页面中，每个独立的页面也被称为一个节点，可以通过**N, P, U**来去到下一个、上一个与上一层的节点，使用**h**能够提供一些基本按键功能的介绍

  当光标在 node 上面，可以使用[Enter]来进入节点

  要查询的目标数据的说明文档必须要以info的格式来写成才能够使用info的特殊功能 (例如超链接)

+ 基础指令

  + `date`显示日期与时间
  + `cal [month] [year]`显示日历
  + `bc`计算器，bc默认仅输出整数，如果要输出小数点后位数，那么就必须要执行scale=number，number是小数点位数

**文字模式重要的三个键**

+ [Tab]具有命令补全与文件补齐的功能
  + 在一串指令的第一个字的后面，则为命令补全
  + 在一串指令的第二个字以后时，则为文件补齐
+ [Ctrl]+c是中断目前程序
+ [Ctrl]+d是键盘输入结束，和Windows系统下的[Ctrl]+z相似
+ [shift]+[PageUP] || [Page Down]是前后翻页

**关机**

+ `who`查看目前谁在线上

+ `sync`将数据同步写入硬盘中的指令

  在Linux系统中为了加快数据的读取速度，所以在默认的情况中， 某些已经载入内存中的数据将不会直接被写回硬盘，而是先暂存在内存当中，如此一来， 如果一个数据被你重复的改写，那么由于它尚未被写入硬盘中，因此可以直接由内存当中读取出来

  万一系统因为某些特殊情况造成不正常关机 (例如停电或者是不小心踢到power)时，由于数据尚未被写入硬盘当中所以就会造成数据的更新不正常，该指令执行后，在内存中尚未被更新的数据，就会被写入硬盘中所，这个指令在系统关机或重新开机之前很重要

  目前的shutdown/reboot/halt 等等指令均已经在关机前进行了sync这个工具的调用

  sync可以被一般帐号使用，只不过一般帐号使用者所更新的硬盘数据就仅有自己的数据，而root可以更新整个系统中的数据

+ `shutdown`关机，必须在root下执行，没有参数默认1分钟后关机

  ![image-20240110164441416](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240110164441416.png)
  
+ `reboot`重新启动系统

+ `halt`停止系统

  该命令会通知硬件停止所有的CPU功能，但仍然保持通电状态。这意味着系统仍然处于低层维护状态，可以进行一些底层维护操作，例如访问硬盘上的数据或使用调试工具

+ `poweroff`关闭系统

  该命令会发送一个ACPI(高级配置和管理电源接口)信号来通知系统关机，并完全关闭计算机的电源。这意味着系统将无法再次启动，除非手动重新启动计算机

上述命令都是调用`systemmctl`指令，目前系统中所有服务的管理都是该指令，是一个非常复杂的指令，有关关机的语法如下：

![image-20240110164908332](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240110164908332.png)

***

# 文件权限与权限配置

使用`su`切换到root，使用`ls -al`指令

+ ls是list的意思，显示文件的文件名与相关属性
+ -al表示列出所有的文件详细的权限与属性，隐藏文件也会显示

```css
-rw-r--r--.  1 xwj  xwj   193 4月   1 2020 .bash_profile
```

+ 第1个字符代表：

  + [ d ]是目录

  + [ - ]是文件

  + [ l ]是链接文件link file

  + [ b ]是设备文件里面的可供储存的接口设备(可随机存取设备)

  + [ c ]是设备文件里面的串行接口设备，例如键盘、鼠标(一次性读取设备)

+ 接下来的字符以3个为一组，且均为`rwx`的组合

  + `r` read：可读取此一文件的实际内容，如读取文本文件的文字内容等
  + `w` write：可以编辑、新增或者是修改该文件的内容(但不含删除该文件)
  + `x` execute：该文件具有可以被系统执行的权限
  
  权限的位置不会改变，如果没有权限就是`-`
  
  + 第1组为文件拥有者可具备的权限User
  + 第2组为加入此群组账号的权限Group
  + 第3组为非本人且没有加入本群组账号的权限Others
  
+ `1`表示有多少文件名硬链接到此文件，每个文件至少有一个硬链接，通常这个硬链接就是文件名本身
  
  硬链接是一个特殊的文件系统对象，它指向同一个索引节点(inode)的不同文件名，硬链接不能跨文件系统，且不能链接到目录
  
  每个文件都有一个与之关联的索引节点，其中存储了文件的元数据(如权限、大小、修改时间等)和数据块指针
  
+ 第1个`xwj`表示这个文件或目录的拥有者账号
  
+ 第2个`xwj`表示这个文件的所属群组
  
+ `193`为文件的大小，单位为bytes
  
+ `4月 1 2020`为文件最近修改日期
  
  内容分别为月 日 时间，如果这个文件被修改的时间距离现在太久，那么时间部分仅显示年份
  
  如果想要显示完整的时间格式，`ls -l --full-time`就能够显示出完整的时间格式
  
+ `.bash_profile`为文件名  

**目录与文件的权限意义并不相同**，这是因为目录与文件所记录的数据内容不相同

文件是存放实际数据的所在，目录主要的内容在记录文件名清单

针对目录时：

+ `r` read contents in directory：表示具有读取目录结构清单的权限，所以当你具有读取一个目录的权限时，表示你可以查询该目录下的文件名数据。就可以利用 `ls` 这个指令将该目录的内容列表显示出来

  

+ `w` modify contents of directory：它表示你具有异动该目录结构清单的权限，也就是下面这些权限：

  + 创建新的文件与目录

  + 删除已经存在的文件与目录(不论该文件的权限为何)

  + 将已存在的文件或目录进行更名

  + 搬移该目录内的文件、目录位置。总之，目录的w权限就与该目录下面的文件名异动有关

    

+ `x` access directory：目录不可以被执行，目录的x代表的是使用者能否进入该目录成为工作目录的用途，所谓的工作目录work directory就是你目前所在的目录，当你登陆Linux时，你所在的主文件夹就是你当下的工作目录

文件是一堆文件数据夹，目录是一堆抽屉，可以将数据夹分类放置到不同的抽屉去，因此抽屉最大的目的是拿出/放入数据夹

![](https://img2024.cnblogs.com/blog/3357226/202401/3357226-20240115210928956-1001584693.png)

<span style="color: orange;">仅拥有r权限，没有x权限是无法执行文件或进入目录的</span>

![](https://img2024.cnblogs.com/blog/3357226/202401/3357226-20240115211701092-1447453915.png)

有`x`就可以执行了，`r`是可选的，如果没有`r`，按Tab无法自动补齐文件名

## 改变文件属性与权限

+ `chgrp` ：改变文件所属群组

   change group，**被改变的群组名称必须要在/etc/group文件内存在，否则就会显示错误**

  ```Css
  chgrp [选项] 群组名 文件或目录
  ```

  选项包括：

  - `-R`：递归地更改文件和目录的所属组，包括子目录和文件

  - `--reference=参考文件或目录`：将文件或目录的所属组设置为参考文件或目录的所属组

  - `-c` 或 `--changes`：效果类似 `-v` 参数，但仅回显更改的部分

  - `-f` 或 `--quiet` 或 `--silent`：不显示错误信息

  - `-h` 或 `--no-dereference`：只对符号连接的文件作修改，而不更动其他任何相关文件

  - `-v` 或 `--verbose`：显示指令执行过程

  - `--dereference`：作用于符号链接的指向，而不是符号链接本身

    

+ `chown` ：改变文件拥有者

  change owner，**在/etc/passwd这个文件中有纪录的使用者名称才能改变**

  ```CSS
  chown [选项] 帐号名:群组名 文件或目录
  ```

  `chown`可以只更改拥有者，也可以同时修改拥有者和群组

  

+ `chmod` ：改变文件的权限, SUID, SGID, SBIT等等的特性

  ```CSS
  chmod [选项] 权限模式 文件或目录
  ```

  + 数字类型改变文件权限

    `r`：4，`w`：2，`x`：1
    
    ```CSS
    chmod 777 .bashrc
    ```
    
    
    
  + 符号类型改变文件权限
  
    `u`：user，`g`：group，`o`：others，`a`：all
    
    ```CSS
    chmod  u=rwx,go=rx  .bashrc
    也可以使用+来加上某个权限
    a+r
    也可以使用-来 减去某个权限
    a-r
    ```

## 文件种类与扩展名

<span style="color: orange;">任何设备在Linux下面都是文件</span>

+ 普通文件regular file

  最基本的一类文件，通常访问的文件，由`ls -la`显示出来的属性中，第一个属性为`-`，根据文件内容可以分为：

  + 纯文本文件ASCLL

  + 二进制文件binary

  + 数据格式文件data

    有些程序在运行的过程当中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件

    

+ 目录directory，第一个属性为`d`

+ 链接文件link

  类似Windows的快捷方式，第一个属性为`I`

+ 设备与设备文件device

  与系统外设相关的一些文件，通常都集中在/dev这个目录之下，通常分为：

  + 区块block设备文件

    就是存储数据以供系统存取的接口设备，如硬盘和软盘，第一个属性为`b`

  + 字符character设备文件

    串行端口的接口设备，如键盘、鼠标，第一个属性为`c`

+ 数据接口文件(套接字)sockets

  通常用在网络数据连接，可以启动一个程序来监听客户端的要求，客户端可以通过套接字来进行数据通信。第一个属性为`s`，最常在 /var/run目录中看到这种文件类型

+ 数据输送档(管道)FIFO

+ FIFO也是一种特殊的文件类型，它的主要目的是解决多个程序同时存取一个文件所造成的错误。FIFO是first-in-first-out(先进先出)的缩写，第一个属性为`p`



**扩展名**

Linux文件没有所谓的扩展名，一个Linux能不能执行与它的权限有关，只要权限具有`x`，这个文件就可以被执行，不过，可以被执行不代表可以执行成功

通常还是会以适当的扩展名来表示该文件是什么种类，以下是常见的扩展名：

1. `.tar`：用于表示一个tar归档文件，通常用于打包多个文件和目录
2. `.gz`：用于表示一个gzip压缩文件，使用gzip压缩算法进行压缩
3. `.bz2`：用于表示一个bzip2压缩文件，使用bzip2压缩算法进行压缩
4. `.tar.gz`或`.tgz`：用于表示一个tar归档文件，同时使用gzip压缩算法进行压缩
5. `.tar.bz2`：用于表示一个tar归档文件，同时使用bzip2压缩算法进行压缩
6. `.rpm`：用于表示一个RPM软件包文件，通常用于Red Hat、Fedora等发行版中
7. `.deb`：用于表示一个Debian软件包文件，通常用于Debian、Ubuntu等发行版中
8. `.so`：Linux系统动态链接库文件，主要作用是在运行时提供运行环境
9. .`sh`：脚本或批处理文件，是一系列shell命令的指令集，工作时sh文件会一行行执行脚本里的指令

**Linux系统上的文件名只是让你了解该文件可能的用途而已，真正的执行与否仍然需要权限的规范才行**

在设置Linux下面的文件名称时，最好可以避免一些特殊字符比较好，例如下面这些：

`? > < ; & ! [ ] | \ ' "  () { }`

因为这些符号在命令行下，是有特殊意义的

同时由于指令下达当中，常常会使用到 `-option` 之类的选项，所以你最好也避免将文件文件名的开头以 `-` 或 `+` 来命名



## Linux目录配置

Filesystem Hierarchy Standard (FHS)标准的重点在于规范每个特定的目录下应该要放置什么样子的数据，避免每个人使用自己的想法来配置文件放置的目录，由此造成很多管理上的困扰

FHS根据文件系统使用的频繁程度和是否允许使用者随意变更两点将目录定义为4种交互作用的形态：

+ 可分享的：可以分享给其他系统挂载使用的目录，所以包括可执行文件与使用者的邮件等数据，是能够分享给网络上其他主机挂载用的目录
+ 不可分享的：自己机器上面运行的设备文件或者是与程序有关的socket文件等，由于仅与自身机器有关，当然就不适合分享给其他主机
+ 不变的：有些数据是不会经常变动的，跟随着distribution而不变动。例如函数库、文件说明文档、系统管理员所管理的主机服务配置文件等等
+ 可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻群组等

事实上FHS针对目录树架构仅定义出三层目录下面应该放置什么数据而已，分别是下面这三个目录的定义：

+ / (root, 根目录)：与开机系统有关
+ /usr (unix software resource)：与软件安装/执行有关
+ /var (variable)：与系统运行过程有关

**FHS要求根目录( / )必须存在的次目录：**

即使没有实体目录，FHS也希望至少有链接文件存在

+ `/bin`

  放置在单人维护模式下还能够被操作的指令。在/bin下面的指令可以被root与一般帐号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令

+ `/boot`

  要在放置开机会使用到的文件，包括Linux核心文件以及开机菜单与开机所需配置文件等等

+ `/dev`

  任何设备与周边设备都是以文件的型态存在于这个目录当中的。只要通过存取这个目录下面的某个文件，就等于存取某个设备

+ `/etc`

  系统主要的配置文件几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等

  一般来说，这个目录下的各文件属性是可以让一般使用者查阅的，但是只有root有权力修改。FHS建议不要放置可可执行文件(binary)在这个目录中

+ `/lib`

  放置在开机时会用到的函数库，以及在/bin或/sbin下面的指令会调用的函数库

  某些指令必须要有这些函数库才能够顺利完成程序的执行

+ `/media`

  可移除的设备，包括软盘、光盘、DVD等等设备都暂时挂载于此

+ `/mnt`

  如果想要暂时挂载某些额外的设备，一般建议放置到这个目录中

+ `/opt`

  存放第三方应用程序或软件包

+ `/run`

  用于存储在系统运行时生成的数据。通常包含一些临时文件和程序运行时所需的信息

+ `/srv`

  一些网络服务启动之后，这些服务所需要取用的数据目录。常见的服务例如WWW, FTP等等

+ `/tmp`

  让一般使用者或者是正在执行的程序暂时放置文件的地方，这个目录是任何人都能够存取的

  

**FHS建议根目录( / )可以存在的次目录：**

+ `/home`

  存放用户的主目录，每个用户在 `/home` 目录下都有一个以其用户名命名的子目录，用于存储该用户的个人文件和配置信息

+ `/lib<qual>`

  用来存放与 /lib 不同的格式的二进制函数库

+ `/root`

  root的主文件夹，之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的主文件夹，所以我们会希望root的主文件夹与根目录放置在同一个分区中

FHS针对根目录所定义的标准就仅有上面几种，下面是几个是在Linux当中非常重要的目录：

+ `/lost+found`

  这个目录是使用标准的ext2/ext3/ext4文件系统格式才会产生的一个目录，当文件系统发生崩溃或意外断电时，可能会导致一些文件被损坏或丢失，这些文件就会被放置在该目录下

+ `/proc`

  是一个虚拟文件系统，它放置的数据都是在内存中，例如系统核心、行程信息(process)、周边设备的状态及网络状态等等

+ `/sys`

  也是虚拟文件系统，主要也是记录核心与系统硬件信息较相关的信息。包括目前已载入的核心模块与核心侦测到的硬件设备信息等等

/proc 主要用于获取系统和进程信息，而 /sys 主要用于访问设备和驱动程序的信息和配置



**/usr**

所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr下面，因此这个目录有点类似Windows 系统的“C:\Windows\ (当中的一部份) + C:\Program files\”这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量

放置的数据属于可分享的与不可变动的(shareable,static)，如果通过网络进行分区的挂载，那么/usr确实可以分享给区域网络内的其他主机来使用

usr是Unix Software Resource的缩写，也就是Unix操作系统软件资源，而不是使用者的数据

FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行创建该软件自己独立的目录

**FHS要求/usr必须存在的次目录**：

+ `/usr/bin/`

  所有一般用户能够使用的指令都放在这里，CentOS 7已经将全部的使用者指令放置于此，而使用链接文件的方式将 /bin 链接至此，也就是说， /usr/bin 与 /bin 是一模一样了，另外FHS要求在此目录下不应该有子目录

+ `/usr/lib/`

  与/lib功能相同，所以/lib就是链接到此目录中的

+ `/usr/local/`

  系统管理员在本机自行安装自己下载的软件，建议安装到此目录，这样会比较便于管理

+ `/usr/sbin/`

  非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件的服务指令，基本功能与 /sbin 也差不多，因此目前 /sbin 就是链接到此目录中的

+ `/usr/share/`

  主要放置只读架构的数据文件，也包括共享文件，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据

**FHS建议/usr可以存在的次目录**：

+ `/usr/games/`

  放置与游戏比较相关的数据

+ /usr/include/

  通常用于存放标准C库的头文件

+ `/usr/libexec/`

  通常用于存放那些不被一般用户直接执行的程序或脚本

+ `/usr/lib<qual>/`

  与 /lib<qual>/功能相同，因此目前 /lib<qual> 就是链接到此目录中

+ `/usr/src/`

  一般源代码建议放置到这里，src有source的意思。至于核心源代码则建议放置到/usr/src/linux/目录下

  

**/var**

/usr是安装时会占用较大硬盘容量的目录，/var是在系统运行后才会渐渐占用硬盘容量的目录。因为/var目录主要针对常态性变动的文件，包括高速缓存cache、登录文件log file以及某些软件运行所产生的文件，包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等

**FHS要求/var必须存在的次目录**：

+ `/var/cache/`

  通常用于存放应用程序或服务在运行过程中缓存的文件

+ `/var/lib/`

  程序本身执行的过程中需要使用到的数据文件放置的目录，在此目录下各自的软件应该要有各自的目录

+ `/var/lock/`

  某些设备或者是文件资源同时只能被一个应用程序所使用，如果同时有两个程序使用该设备时，就可能产生一些错误的状况，因此就得要将该设备上锁，以确保该设备只会给单一软件所使用

+ `/var/log/`

  用于存放系统日志文件。这些日志文件记录了系统运行期间的各种事件、警告、错误等信息，以便管理员进行故障排除和监控，登录文件也放在这里

+ `/var/mail/`

  放置个人电子邮件信箱的目录，这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件

+ `/var/run/`

  某些程序或者是服务启动后，会将他们的PID放置在这个目录，与 /run 相同，这个目录链接到 /run

+ `/var/spool/`

  通常用于存放待处理的任务和数据。这些任务和数据通常是由系统或应用程序在后台异步处理，因此暂时存放在该目录下

**FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据，因此，在其他次目录层级内，就可以随开发者自行来配置**

**所有的文件与目录都是由根目录开始的**

+ 目录树的启始点为根目录(/, root)
+ 每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem
+ 每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的

**绝对路经和相对路径**

+ 绝对路径：由根目录(/)开始写起的文件名或目录名称，例如 /home/dmtsai/.bashrc
+ 相对路径：相对于当前路径的文件名写法。例如 ./home/dmtsai 或 ../../home/dmtsai/ 等等。**反正开头不是 / 就属于相对路径的写法**
  + `.` ：代表当前的目录，也可以使用`./`来表示
  + `..` ：代表上一层目录，也可以`../`来代表

***

# Linux文件与目录管理

+ `.` ：当前目录

+ `..`：上一层目录

+ `-` ：前一个工作目录

+ `~` ：“目前使用者身份”所在的主文件夹

  ~account代表account这个使用者的主文件夹(account是帐号名称)

根目录的上一层(..)与根目录自己(.)是同一个目录

**常见的处理目录指令**

+ `cd`：变换目录

  没有加上任何路径和单独一个`~`一样，就是回到自己主文件夹

+ `pwd`：显示目前的目录

  加上`-P`选项：显示确定的路径，而不是链接路径，注意是大写

  ![](https://img2024.cnblogs.com/blog/3357226/202401/3357226-20240117123603204-1870065975.png)

+ `mkdir`：创建一个新的目录

  默认情况下目录需要一层一层的创建，不能一次性输入多层

  加上`-p`选项：帮助创建多层目录，如果该目录本来就已经存在时，系统也不会显示错误讯息

  加上`-m`选项：设置文件的权限

+ `rmdir`：删除一个空的目录

  加上`-p`选项：将上层空的目录一并删除

**PATH**

环境变量用于指定一系列目录或位置，系统在其中查找要执行的命令或程序

```CSS
echo $PATH
/*查看目前的环境变量，目录是有顺序的，每个目录中间使用冒号来隔开*/
PATH="${PATH}:/root"
/*将/root加入到可执行文件搜寻路径PATH中*/
```

+ 不同身份使用者默认的PATH不同，默认能够随意执行的指令也不同
+ 使用绝对路径或相对路径直接指定某个指令的文件名来执行，会比搜寻PATH更正确
+ 本目录(.)最好不要放到PATH当中

## 文件与目录管理

**文件与目录的检视：ls(list)**

```CSS
ls [选项与参数] 文件名或目录名
-a：全部的文件，连同隐藏文件一起列出
-A：全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录
-d：仅列出目录本身，而不是列出目录内的文件数据
-f：直接列出结果，而不进行排序(ls默认会以文件名排序)
-F：根据文件、目录等信息，给予附加数据结构
	*:代表可可执行文件
	/:代表目录
	=:代表socket文件
	&#124:代表FIFO文件
-h：将文件大小以人类较易读的方式(例如 GB, KB 等等)列出来
-i：列出inode号码
-l：长数据串行出，包含文件的属性与权限等等数据
-n：列出UID与GID而非使用者与群组的名称
-r：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小
-R：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来
-S：以文件大小大小排序，而不是用文件名排序
-t：依时间排序，而不是用文件名
--color=never：不要依据文件特性给予颜色显示
--color=always：显示颜色
--color=auto：让系统自行依据设置来判断是否给予颜色
--full-time：以完整时间模式(包含年、月、日、时、分)输出
--time={atime,ctime} ：输出 access 时间或改变权限属性时间(ctime)而非内容变更时间
```

**选项可以叠加**

**复制:cp(copy)**

```CSS
cp [选项] 源文件或目录 目标文件或目录
-a：相当于-dr --preserve=all的意思
-d：若来源文件为链接文件的属性(link file)，则复制链接文件属性而非文件本身
-f：为强制(force)的意思，若目标文件已经存在且无法打开，则移除后再尝试一次
-i：若目标文件(destination)已经存在时，在覆盖时会先询问动作的进行
-l：进行硬链接(hard link)的链接文件创建，而非复制文件本身
-p：连同文件的属性(权限、用户、时间)一起复制过去，而非使用默认属性(备份常用)
-r：递回持续复制，用于目录的复制行为
-s：复制成为符号链接文件(symbolic link)
-u：destination比source旧才更新destination，或destination不存在的情况下才复制
--preserve=all：除了-p的权限相关参数外，还加入SELinux的属性, links,xattr等也复制了。如果来源文件有两个以上，则最后一个目的文件一定是目录
```

`-r`可以复制目录，但文件与目录的权限可能会改变，使用`-a`则不会

某些需要特别注意的特殊权限文件，例如密码档(/etc/shadow)以及一些配置文件，就不能直接以`cp`来复制，而必须要加上`-a`或者是`-p`等可以完整复制文件权限的选项，另外如果想要复制文件给其他的使用者，也必须要注意到文件的权限，包含读、写、执行以及文件拥有者等等

使用`-l`及`-s`都会创建所谓的链接文件(link file)，但是这两种链接文件不一样

`-l`是实体链接(hard link)， `-s`则是符号链接(symbolic link)，简单来说，bashrc_slink 是一个“捷径”，这个捷径会链接到bashrc去，所以文件名右侧会有个指向(->)的符号

**删除：rm(remove)**

```CSS
rm [选项] 文件或目录
-f：force的意思，忽略不存在的文件，不会出现警告讯息
-i：互动模式，在删除前会询问使用者是否动作
-r：递回删除，最常用在目录的删除，这是非常危险的选项
可以使用*来代替n个字符
```

**移动：mv(move)**

```CSS
mv [选项] 源文件或目录 目标文件或目录
-f：force的意思，如果目标文件已经存在，不会询问而直接覆盖
-i：若目标文件(destination)已经存在时，就会询问是否覆盖
-u：若目标文件已经存在，且源文件比较新，才会更新

 mv mvtest mvtest
可以使用mv来更名
使用另一个指令rename可以更改大量文件的文件名
```



## 文件内容查询

+ `cat`(concatenate)：由第一行开始显示文件内容

  ```CSS
  cat [选项] 文件名
  -A：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白
  -b：列出行号，空白行不标行号
  -n：打印出行号，空白行也会有行号
  -E：将结尾的断行字符 $ 显示出来
  -T：将 [tab] 按键以 ^I 显示出来
  -v：列出一些看不出来的特殊字符
  ```

  

+ `tac`：从最后一行开始显示

  ```CSS
  tac [选项] 文件名
  ```

+ `nl`：添加行号打印

  ```CSS
  nl [选项] 文件名
  b：指定行号指定的方式，主要有两种：
  	-b a：空行同样列出行号
  	-b t：空行不列出行号(默认值)
  -n：列出行号表示的方法，主要有三种：
  	-n ln：行号在屏幕的最左方显示
  	-n rn：行号在自己字段的最右方显示，且不加0
  	-n rz：行号在自己字段的最右方显示，且加0
  -w：行号字段的占用的字符数
  ```

+ `more`：一页一页的显示文件内容

  ```CSS
  more [选项] 文件名
  +：从指定行开始输出
  -：指定每屏显示的行数
  +n：显示文件中的第n行之后的内容
  -n：显示文件中的前n行内容
  
  最后一行会显示出目前显示的百分比，而且还可以在最后一行输入一些有用的指令：
  space：代表向下翻一页
  Enter ：代表向下翻一行
  /字符串：代表在这个显示的内容当中，向下搜寻这个字符串
  :f：立刻显示出文件名以及目前显示的行数
  q：离开more 
  b或[ctrl]-b ：代表往回翻页，只对文件有用
  ```

+ `less`与`more`类似，但是它可以往前翻页

  ```CSS
  less [选项] [文件名]
  less更加灵活，有更多的指令：
  space：向下翻动一页
  pagedown：向下翻动一页
  pageup：向上翻动一页
  /字符串：向下搜寻字符串
  ?字符串：向上搜寻字符串
  n：重复上一个搜寻
  N：反向的重复上一个搜寻
  g：跳到文件开头
  G：跳到文件末尾
  q：离开less
  ```

+ `head`：显示文件前几行

  ```CSS
  -n 100
  /*显示前100行*/
  -n -100
  /*最后100行不会显示*/
  ```

+ `tail`:显示文件后几行

  ```CSS
  -n 20
  /*显示最后20行*/
  -n 20
  /*显示20行以后所有数据*/
  -f：在查看文件内容时实时追踪文件的变化，在文件更新时实时刷新输出，按下[ctrl]-c才会结束tail的追踪
  ```

+ `od`：以不同的格式显示文件内容

  ```CSS
  -t：后面可以接各种类型的输出：
  	a：默认的字符来输出
  	c：使用ASCII字符来输出
  	d[size]：利用十进制(decimal)来输出数据,每个整数占用size Bytes
  	f[size]：利用浮点数值(floating)来输出数据，每个数占用 size Bytes
  	o[size]：利用八进位(octal)来输出数据，每个整数占用size Bytes
  	x[size]：利用十六进制(hexadecimal)来输出数据，每个整数占用size Bytes
  ```

**管线(|)的意思是：前面的指令所输出的讯息，通过管线交由后续的指令继续使用**

```CSS
cat -n /etc/man_db.conf | head -n 20 |tail -n 10
/*使用-n列出前20行及行号后，交由tail显示后10行*/
```

**修改文件时间或创建新文件**

每个文件在linux下面都会记录许多的时间参数，有三个主要的变动时间：

+ modification time (mtime)：当该文件的内容数据变更时，就会更新这个时间，内容数据指的是文件的内容，而不是文件的属性或权限
+ status time (ctime)：当该文件的状态(status)改变时，就会更新这个时间，权限与属性被更改都会更新这个时间
+ access time (atime)：当该文件的内容被取时，就会更新这个读取时间(access)，使用cat去读取 /etc/man_db.conf ，就会更新该文件的atime

默认的情况下，ls显示出来的是该文件的mtime

`touch`命令可用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件

```CSS
touch [选项] 文件或目录
-a：仅修改access time
-c：仅修改文件的时间，若该文件不存在则不创建新文件
-d：后面可以为修改日期，也可以使用--date="日期或时间"
-m：仅修改mtime
-t：后面可以为修改日期，格式为[YYYYMMDDhhmm]

#touch test
直接创建该文件
```



## 文件与目录的默认权限&隐藏权限&特殊权限

+ 创建文件默认权限为`-rw-rw-rw-`
+ 创建目录默认权限为`drwxrwxrwx`

```CSS
#umask
0022
指定目前使用者在创建文件或目录时的权限默认值
umask的数字是该默认值需要减掉的权限

加-s以符号类型显示
#umask -s
u=rwx,g=rx,o=rx
```

更改权限直接在`umask`后输入数字即可

**chattr指令只能在Ext2/Ext3/Ext4的传统文件系统上完整生效，其他文件系统可能无法完整支持该指令**

**`chattr`：设置文件隐藏属性**

```CSS
# chattr [选项] 文件名或目录名
+：增加某一个特殊参数，其他原本存在参数不变
-：移除某一个特殊参数，其他原本存在参数不变
=：将文件的属性设置为指定的参数，并且只有后面接的参数会被设置，其他属性将被移除
参数：
A：若存取此文件(或目录)时，它的存取时间atime将不会被修改，可避免I/O较慢的机器过度的存取磁盘(目前建议使用文件系统挂载参数处理这个项目)
a：这个文件将只能增加数据，而不能删除也不能修改数据，只有root才能设置这属性
S：一般文件是非同步写入磁盘的，加上这个属性时，当你进行任何文件的修改，该更动会同步写入磁盘中
s：如果这个文件被删除，他将会被完全的移除出这个硬盘空间，所以如果误删了，完全无法找回
u：与s相反，如果该文件被删除了，则数据内容其实还存在磁盘中
c：将会自动的将此文件压缩，在读取的时候将会自动解压缩，在储存的时候，将会先进行压缩后再储存(对于大文件似乎有用的)
d：当dump程序被执行的时候，设置d属性将可使该文件(或目录)不会被 dump备份
i：不能被删除、改名、设置链接也无法写入或新增数据，对于系统安全性有相当大的帮助，只有root能设置此属性
```

**`lsattr`：显示文件隐藏属性**

```CSS
-a ：隐藏文件的属性也列出
-d ：如果是目录，仅列出目录本身的属性而非目录内的文件名
-R ：连同子目录的数据也一并列出来
```

**文件特殊权限**

除了rwx读写执行三种权限，还有两种特殊权限s和t，这两个权限的意义与系统账号和系统程序相关

当s这个标志出现在文件拥有者的x权限上时，此时就被称为Set UID，简称为SUID的特殊权限

**SUID**：

+ 仅对二进制程序有效
+ 执行者对于该程序需要具有x的可执行权限
+ 执行者在执行该程序的过程中将具有该程序拥有者的权限

s在群组的x时则为Set UID，SGID可以针对文件或目录来设置

**SGID**：

+ SGID对二进制程序有用
+ 程序执行者对于该程序来说，需具备x的权限
+ 执行者在执行的过程中将会获得该程序群组的支持

当一个目录设置了SGID的权限后，将具有如下的功能：

+ 使用者若对于此目录具有r与x的权限时，该使用者能够进入此目录

+ 使用者在此目录下的有效群组将会变成该目录的群组

  用途：若使用者在此目录下具有w的权限，则使用者所创建的新文件的群组与此目录的群组相同

**SBIT**：

Sticky Bit只对目录有效：

+ 当使用者对于此目录具有w, x权限，亦即具有写入的权限
+ 当使用者在该目录下创建文件或目录时，仅有自己与root才有权力删除该文件

**特殊权限设置**

依旧使用`chmod`改变权限

+ 4为SUID
+ 2为SGID
+ 1为SBIT

第一位就是文件特殊权限设置位，**SUID不能在目录上设置，SBIT不能在文件上设置**

```CSS
#chmod 7666 test; ls -l test &lt;
-rwSrwSrwT 1 root root 0 Jun 16 02:53 tes
普通权限是6，此处的大写S和T表示的是空

同样可以使用符号类型表示
SUID为u+s
SGID为g+s
SBIT为o+t
```

**file**

用于识别文件类型

```CSS
#file ./adjtime
./adjtime: ASCII text
```

## 指令与文件的搜寻

**`which`：在PATH中搜寻指定的命令**

```CSS
which [-a] commond
-a：将所有由PATH目录中可以找到的指令均列出，而不止第一个被找到的指令名称
```

**`whereis`：在一些特定目录中寻找文件名**

```CSS
-l:列出whereis会去查询的几个主要目录
-b:只找binary格式的文件
-m:只找在说明文档manual路径下的文件
-s:只找source来源文件
-u:搜寻不在上述三个项目当中的其他特殊文件
```

**`locate`**

```CSS
-i：忽略大小写的差异
-c：不输出文件名，仅计算找到的文件数量
-l：输出几行，输出五行则是-l 5
-S：输出locate所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等
-r：后面可接正则表达式的显示方式
```

只需在后面输入文件部分名称就能得到结果

虽然寻找数据特别块，但因为`locate`寻找的数据是由已创建的数据库/var/lib/mlocate/里面的数据所搜寻到的，而数据库的创建是在每天执行一次，所以当新创建起来的文件，却还在数据库更新之前搜寻该文件，那么`locate`将搜寻不到

可以手动更新，直接输入`updatedb`即可，可能等待数分钟时间

**whereis只找系统中某些特定目录下面的文件，locate则是利用数据库来搜寻文件名**

**`find`**

```CSS
find [路径] [选项]
/*某个时间段的文件*/
-mtime  n ：n 为数字，意义为在n天之前的一天之内被更动过内容的文件
-mtime +n ：列出在n天之前(不含n天)被更动过内容的文件文件名
-mtime -n ：列出在n天之内(含n天本身)被更动过内容的文件文件名
-newer file ：file为一个存在的文件，列出比file还要新的文件文件名

/*属于*的文件*/
-user name ：name为使用者帐号名
-group name：name为群组名
-nouser：拥有者不存在/etc/passwd的文件
-nogroup：拥有群组不存在于/etc/group的文件
当自行安装软件时，很可能该软件的属性当中并没有文件拥有者，这个时候就可以使用-nouser与-nogroup搜寻

/*文件权限和属性*/
-name filename：搜寻文件名称为filename的文件，可以使用*通配符
-size [+-]SIZE：搜寻比SIZE还要大(+)或小(-)的文件
	SIZE的规格有：
	c: 代表Byte
	k: 代表1024B
	要找比50KB还要大的文件，就是#-size +50k
-type TYPE：搜寻文件的类型为TYPE的
	类型主要有：一般文件(f), 设备文件(b, c),目录(d), 链接文件(l), socket (s), FIFO (p)等属性
-perm mode  ：搜寻文件权限为mode的文件
	搜寻-rwxr--r-- ，亦即0744的文件，使用-perm -0744
	当一个文件权限为-rwsr-xr-x ，亦即4755时，也会被列出来，因为-rwsr-xr-x的属性已经包括-rwxr--r--的属性
-perm /mode ：搜寻文件权限包含任一mode的权限的文件
	搜寻-rwxr-xr-x ，亦即 -perm /755 时
	一个文件属性为-rw-------也会被列出来，因为他有-rw....的属性存在

/*额外操作*/
-exec command ：command为其他指令，-exec后面可再接额外的指令来处理搜寻到的结果
	{}代表的是由 find 找到的内容，find的结果会被放置到{}位置中
	从-exec一直到\;是关键字，代表find额外动作的开始(-exec)到结束(\;)，在这中间的就是 find 指令内的额外动作
	; 在bash环境下是有特殊意义的，可以使用反斜线(\)来转义
-print：将结果打印到屏幕上，这个动作是默认动作
```

**find本身就会搜寻次目录**

如果要找的文件是具有特殊属性的，例如 SUID 、文件拥有者、文件大小等等，那么利用`locate`是没有办法达成搜寻，只能使用`find`，不过`find`在寻找数据后相当的操硬盘，所以尽量不要使用`find` 

***

# 磁盘与文件系统管理

磁盘分区完毕后还需要进行格式化，之后操作系统才能够使用这个文件系统。进行格式化是因为每种操作系统所设置的文件属性/权限并不相同，为了存放这些文件所需的数据，因此就需要将分区进行格式化，以成为操作系统能够利用的文件系统格式file system

Linux操作系统Ext文件格式的文件系统通常会将文件权限（rwx）与文件属性（拥有者、群组、时间参数等）这两部份的数据分别存放在不同的区块：

+ 权限与属性放置到`inode`中
  + `inode`：记录文件的属性，一个文件占用一个`inode`，同时记录此文件的数据所在的`block`号码
+ 实际数据则放置到`data block`区块中
  + `block`：实际记录文件的内容，若文件太大时，会占用多个`block`
+ 还有一个超级区块`superblock`会记录整个文件系统的整体信息，包括`inode`与`block`的总量、使用量、剩余量等
  + `superblock`：记录文件系统的整体信息，包括inode/block的总量、使用量、剩余量，以及文件系统的格式与相关信息等

每个`inode`与`block`都有编号，每个文件都会占用一个`inode` ，`inode`内则有文件数据放置的`block`号码。如果能够找到文件的`inode`的话，那么自然就会知道这个文件所放置数据的`block`号码，当然也就能够读出该文件的实际数据

![](https://img2024.cnblogs.com/blog/3357226/202401/3357226-20240119135318837-627134864.png)

文件系统先格式化出inode与block的区块，假设某一个文件的属性与权限数据是放置到inode4 号（小方格内），而这个inode记录了文件数据的实际放置点为 2, 7, 13, 15 这四个 block 号码，此时我操作系统就能够据此来排列磁盘的读取顺序，可以一次性将四个block内容读出，数据读取就如同图中箭头所指

**这种数据存取的方法称为索引式文件系统indexed allocation**，U盘使用的文件系统一般为FAT格式，该格式的文件系统没有`inode`存在，所以FAT无法将这个文件的所有`block`在一开始就读取出来。每个`block`号码都记录在前一个`block`当中

![](https://img2024.cnblogs.com/blog/3357226/202401/3357226-20240119140519064-502505748.png)

磁盘重组的原因就是文件写入的`block`太过于离散了，此时文件读取的性能将会变的很差所致。这个时候可以通过磁盘重组将同一个文件所属的`blocks`汇整在一起

**每个文件都会占用一个inode，且可依据文件内容的大小来分配多个block给该文件使用**

**目录记录文件名，文件记录数据内容**

目录与文件在文件系统中如何记录数据：

+ 目录

  在Linux下的文件系统创建一个目录时，文件系统会分配一个inode 与至少一块block给该目录。inode记录该目录的相关权限与属性，并记录分配到的那块block号码；而block则是记录在这个目录下的文件名与该文件名占用的inode号码数据

+ 文件

  在Linux下的ext2创建一个一般文件时，ext2会分配一个inode和相对于该文件大小的block数量给该文件。假设有一个block为4 KBytes ，而要创建一个100KBytes的文件，那么Linux将分配一个inode与25 个block来储存该文件

+ 目录树读取

  **inode本身并不记录文件名，文件名的记录是在目录的block当中**，当要读取某个文件时，就必会经过目录的inode与block，然后找到那个待读取文件的inode号码，最终读到正确的文件的block内的数据。由于目录树是由根目录开始读起，因此系统通过挂载的信息可以找到挂载点的inode号码，此时就能够得到根目录的inode内容，并依据该inode读取根目录的block内的文件名数据，再一层一层的往下读到正确的文件名

**非同步处理**：当系统载入一个文件到内存后，如果该文件没有被更动过，则在内存区段的文件数据会被设置为clean，如果内存中的文件数据被更改过，此时该内存中的数据会被设置为Dirty。此时所有的动作都还在内存中执行，并没有写入到磁盘中。系统会不定时的将内存中设置为Dirty的数据写回磁盘，以保持磁盘与内存数据的一致性。以此来提高编辑大型文件频繁写入/读取磁盘的效率问题

**Linux系统的文件系统与内存有很大关系：**

+ 系统会将常用的文件数据放置到内存的缓冲区，以加速文件系统的读/写
+ 承上，因此Linux的实体内存最后都会被用光，这是正常的情况，可加速系统性能
+ 可以手动使用sync来强迫内存中设置为Dirty的文件回写到磁盘中
+ 若正常关机时，关机指令会主动调用sync来将内存的数据回写入磁盘内；但若不正常关机（如跳电、死机或其他不明原因），由于数据尚未回写到磁盘内，因此重新开机后可能会花很多时间在进行磁盘检验，甚至可能导致文件系统的损毁（非磁盘损毁）

**挂载点的意义**

每个filesystem都有独立的 inode / block / superblock 等信息，这个文件系统要能够链接到目录树才能被使用。将文件系统与目录树结合的动作称为挂载

**挂载点一定是目录，该目录为进入该文件系统的入口**。因此并不是你有任何文件系统都能使用，必须要挂载到目录树的某个目录后，才能够使用该文件系统

## 文件系统的简单操作

+ `df`：列出文件系统的整体磁盘使用量

  ```CSS
  -a ：列出所有的文件系统，包括系统特有的/proc等文件系统
  -k：以KB的容量显示各文件系统
  -m：以MB的容量显示各文件系统
  -h：以人们较易阅读的GB,MB, KB等格式自行显示
  -H：以M=1000K取代M=1024K的进位方式
  -T：增加显示每个挂载点的文件系统类型
  -i：不用磁盘容量，而以inode的数量来显示
  ```

  输出的结果讯息：

  + Filesystem：代表该文件系统是在哪个partition ，所以列出设备名称1k-blocks：说明下面的数字单位是1KB
  + Used：使用掉的磁盘空间
  + Available：剩下的磁盘空间大小
  + Use%：就是磁盘的使用率，如果使用率高达 90% 以上时，最好需要注意一下了，免得容量不足造成系统问题（例如最容易被灌爆的 /var/spool/mail 这个放置邮件的磁盘）
  + Mounted on：磁盘挂载的目录所在

  

+ `du`：评估文件系统的磁盘使用量（常用在推估目录所占容量）

  ```CSS
  -a：列出所有的文件与目录容量，默认仅统计目录下面的文件量
  -h：以人们较易读的容量格式（G/M）显示
  -s：列出总量，而不列出每个各别的目录占用容量
  -S：不包括子目录下的总计
  -k：以KB列出容量显示
  -m：以MB列出容量显示
  ```

Linux的链接文件有两种：

符号链接(软链接)：类似Windows的捷径功能的文件，可以快速的链接到目标文件或目录

实体链接(硬链接)：通过文件系统的inode链接来产生新文件名，而不是产生新文件

+ hard link硬链接

  ![](https://img2024.cnblogs.com/blog/3357226/202401/3357226-20240119163851063-1608888847.png)

可以通过1或2的目录之inode指定的block找到两个不同的文件名，而不管使用哪个文件名均可以指到real那个inode去读取到最终数据，(就像是创建C++里的引用)

**hard link不能跨file system，也不能link目录**

+ symbolic link软链接

  是创建了一个独立的文件，这个文件会让数据的读取指向它link的那个文件的文件名，由于只是利用文件来做为指向的动作，所以当来源文件被删除之后，将无法打开该文件(就像快捷方式)

  ```CSS
  #ln 目标文件或目录的路径 创建的软链接的路径
  -s：不加任何参数就是hard link， -s就是symbolic link
  -f：如果目标文件存在时，就将目标文件直接移除后再创建
  ```

  ![](https://img2024.cnblogs.com/blog/3357226/202401/3357226-20240119170018419-135632589.png)

  由1号inode读取到链接文件的内容仅有文件名，根据文件名链接到正确的目录去取得目标文件的inode，最终就能够读取到正确的数据

## 磁盘的分区、格式化、检验与挂载

**`lsblk`：列出系统上所有磁盘**

```CSS
#lsblk [options] device
-d：仅列出磁盘本身，不会列出该磁盘的分区数据
-f：同时列出该磁盘内的文件系统名称
-i：使用ASCII的线段输出，不使用复杂的编码（某些环境下很有用）
-m：同时输出该设备在/dev下面的权限数据（rwx的数据）
-p：列出该设备的完整文件名，而不是仅列出最后的名字
-t：列出该磁盘设备的详细数据，包括磁盘队列机制、预读写的数据量大小等
```

默认输出信息：

+ NAME：设备的文件名，会省略/dev等前导目录
+ MAJ:MIN：核心认识的设备都是通过这两个代码来熟悉的！分别是主要：次要设备代码
+ RM：是否为可卸载设备removable device，如光盘、USB 磁盘等等
+ SIZE：容量
+ RO：是否为只读设备
+ TYPE：是磁盘disk、分区partition还是只读存储器rom等
+ MOUTPOINT：挂载点

**`blkid`：列出设备的UUID等参数**

universally unique identifier是全域单一识别码，Linux会将系统内所有的设备都给予一个独一无二的识别码，这个识别码就可以拿来作为挂载或者是使用这个设备/文件系统

**`parted`：列出磁盘的分区表类型与分区信息**



**文件系统挂载与卸载**

+ 单一文件系统不应该被重复挂载在不同的挂载点（目录）中
+ 单一目录不应该重复挂载多个文件系统
+ 要作为挂载点的目录，理论上应该都是空目录

```CSS
#mount -t 文件系统类型 -o 选项 设备文件名 挂载点

-o：后面可以接一些挂载时额外加上的参数，比方说帐号、密码、读写权限等：
	async, sync:此文件系统是否使用同步写入（sync）或非同步（async）的内存机制，默认为async
	atime,noatime: 是否修订文件的读取时间（atime），为了性能某些时刻可使用noatime
	ro, rw:挂载文件系统成为只读（ro）或可读写（rw）
	auto, noauto:是否允许此filesystem被以mount -a自动挂载（auto）  	
	dev, nodev:是否允许此filesystem上可创建设备文件，dev为可允许     
	suid, nosuid:是否允许此filesystem含有suid/sgid的文件格式       exec, noexec:是否允许此filesystem上拥有可执行binary文件         user, nouser:是否允许此filesystem让任何使用者执行mount，一般来说，mount仅有root可以进行，但下达user参数，则可让一般user也能够对此partition进行mount
	defaults:默认值为：rw, suid, dev, exec, auto, nouser, and async
	remount:重新挂载，在系统出错或重新更新参数时很有用
```



<span style="color: orange;"></span>

<span style="color: orange;"></span>

<span style="color: orange;"></span>
