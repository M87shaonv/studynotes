# 基础知识

**学习汇编主要是：学习汇编的编程思想，掌握机器运行的思维**

机器语言是机器指令的集合，机器指令是一列二进制数，计算机将之转为一系列高低电平

1. 汇编语言是直接在硬件上工作的编程语言，首先要了解硬件系统的结构，才能有效的应用汇编语言对其编程

3. 汇编语言的主体是汇编指令汇编指令和机器指令的差别在于指令的表示方法上

   汇编指令就是机器指令便于记忆的书写格式

4. 汇编语言是机器指令的助记符

5. 汇编语言的组成

   1. 汇编指令（机器码的助记符）

   2. 伪指令（由编译器执行）

   3. 其他符号（由编译器识别，如：+ - * /）

+ 汇编语言的核心是汇编指令，决定了汇编语言的特性
+ 指令和数据是应用上的概念，在计算机内部这些都是二进制信息

6. CPU对存储器的读写

   存储单位从零开始顺序编号，一个存储单位为1Byte

   CPU要想进行数据的读写，必须和外部器件（即芯片）进行三类信息的交互

   1. 地址信息：存储单元的地址
   2. 控制信息：芯片的选择，读或写命令
   3. 数据信息：读或写的数据

7. 每一个CPU芯片都有许多管脚，这些管脚与总线相连

   1. AB的宽度决定CPU的寻址能力

      CPU的寻址能力是指CPU最多可以在内存中寻找到的地址数量，这个数量是由地址总线的位数决定的。
      **如果地址总线有32根线，那么CPU的寻址能力就是2^32^次方个地址，即4G个地址**

   2. DB的宽度决定CPU与其他器件进行数据传输时的一次数据传输量

      **8根数据总线一次可传输8位二进制数据，也就是1字节**

   3. CB的宽度决定CPU对系统中其它器件的控制能力

      控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制

8. 每一种CPU都有自己的汇编指令集

存储器在物理上是独立的器件，但是在以下两点上相同

+ 都和CPU的总线相连
+ CPU对它们进行读或写的时候都通过控制线发出内存读写命令

<!--  -->

# 寄存器(内部工作原理)

+ 一个典型的CPU由**运算器、控制器、寄存器**等器件组成，这些器件靠内部总线相连。

+ 区别：
  + 内部总线实现CPU内部各个器件之间的联系
  + 外部总线实现CPU和主板上其它器件的联系

8086CPU有14个寄存器，名称分别为：
	AX，BX，CX，DX，SI，DI，SP，BP，IP，CS，SS，DS，ES，PSW

8086CPU所有的寄存器都是16位的，可以存放两个字节

AX、BX、CX、DX 通常用来存放一般性数据被称为通用寄存器

+ 一个16位寄存器可以存储一个16位的数据（数据的存放情况）
+ **一个16位寄存器所能存储的数据的最大值为2^16^-1**

+ 为保证兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用

+ H为高位，L为低位
  + AX可以分为AH和AL
  + BX可以分为BH和BL
  + CX可以分为CH和CL
  + DX可以分为DH和DL

+ AX的低8位（0位 ~ 7位）构成了AL寄存器，高8位（8位 ~ 15位）构成了AH寄存器
  **AH和AL寄存器是可以独立使用的8位寄存器**

![](D:\electric book\学习笔记\计算机组成与原理\汇编_img_ass\2.1.png)

![](D:\electric book\学习笔记\计算机组成与原理\汇编_img_ass\2.1.1.png)

+ 字为Word，一个字由两个字节也就是16bit组成，两个字节分别称为这个字的高位字节和低位字节

+ **汇编指令不区分大小写**

  ```CSS
  /*汇编指令		高级语言语法描述*/
  mov ax,18	     AX=18
  mov ah,78   	 AH=78
  add ax,8  	 	 AX+=8
  mov ax,bx    	 AX=BX
  add ax,bx      	 AX+=BX
      
  /*AX值为00C5H*/
  add al,93H	     AL+=93H   
  结果为：C5+93==0158
  但al为8位寄存器，只能存放两位十六进制数据，最高位1会丢失，AX值为0058H
  这里的丢失，指的是进位值不能在8位寄存器中保存，但是CPU并不真的丢弃这个进位值
  
+ 因此在进行数据传输或运算时要注意两个指令的两个操作对象的位数应当是一致的

## 内存单元

**物理地址**

+ CPU访问内存单元时要给出内存单元的地址
+ 所有的内存单元构成的存储空间是一个一维的线性空间
+ 将这个唯一的地址称为物理地址

8086是16位结构的CPU：

- 运算器一次最多处理16位数据
- 寄存器最大宽度为16位
- 寄存器和运算器之间的通路为16位

总之16位CPU能够一次性处理、传输、暂存16位的地址

8086有20位地址总线，可传送20位地址，寻址能力为1M，但8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力只有64K。

解决这个矛盾的方法是：8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址

<img src="D:\electric book\学习笔记\计算机组成与原理\汇编_img_ass\物理地址方法.png"  />

1. CPU中的相关部件提供两个16位的地址，一个称为段地址SA（SegmentAddress），另一个称为偏移地址也称有效地址EA（EffectiveAddress）

2. 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件

3. 地址加法器将两个16位地址合并成一个20位的地址

+ 地址加法器合成物理地址的方法：

  ​    **物理地址=段地址×16+偏移地址**，本质是**物理地址=基础地址+偏移地址**的一种具体实现

  段地址x16也就是数据左移4位(数据都是二进制位存放)
  
  一个数据的二进制形式左移N位，相当于该数据乘以2的N次方

<img src="D:\electric book\学习笔记\计算机组成与原理\汇编_img_ass\地址加法器工作原理.png"  />

+ **段的概念**：内存并没有分段，段的划分来自CPU，由于8086CPU采用物理地址=段地址×16+偏移地址的方式给出内存单元的物理地址，使我们可以用分段的方式管理内存
+ 在编程时可以根据需要将若干地址连续的内存单元看作一个段，用段地址×16定位段的起始地址(基础地址)，用偏移地址定位段中的内存单元
  1. 段地址×16 必然是 16的倍数，所以一个段的起始地址也一定是16的倍数
  2. 偏移地址为16位，16 位地址的寻址能力为 64K，所以一个段的长度最大为64K



+ **CPU访问内存单元时，必须向内存提供内存单元的物理地址**

![](D:\electric book\学习笔记\计算机组成与原理\汇编_img_ass\图片1.png)

+ **CPU可以用不同的段地址和偏移地址形成同一个物理地址**

+ 数据在21F60H内存单元中。对于8086PC机的两种描述：

  A. 数据存在内存2000:1F60单元中

  B. 数据存在内存的2000段中的1F60H单元中

## 段寄存器

**段寄存器**：存放段地址。8086CPU有4个段寄存器：CS、DS、SS、ES
当8086CPU要访问内存时，由这4个段寄存器提供内存单元的段地址

+ **CS存放指令的段地址，IP存放指令的偏移地址**

**CS**(代码段寄存器)和**IP**(指令指针寄存器)是8086CPU中最关键的两个寄存器，它们指示CPU当前要读取指令的地址

![](D:\electric book\学习笔记\计算机组成与原理\汇编_img_ass\读取和执行指令.png)

1. 从CS:IP指向的内存单元读取指令，进入指令缓冲器
2. IP=IP+所读取指令长度，从而指向下一条指令
3. 执行指令。转到步骤1，重复该过程

+ 在8086CPU加电启动或复位后(即CPU刚开始工作时)，CS和IP被设置为CS=FFFFH，IP=0000H
+ 即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行
+ FFFF0H单元中的指令是8086PC机开机后执行的第一条指令
+ 在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行
+ 如果内存中的一段信息曾被CPU执行过的话，那么它所在的内存单元必然被CS:IP指向过

CPU从何处执行指令是由CS和IP中的内容决定的，程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令

**mov指令不能用于设置CS、IP的值**

```cSS
/*修改CS、IP的指令*/
jmp 段地址:偏移地址
/*段地址修改CS，偏移地址修改IP*/
    
/*用寄存器中的值修改IP*/
jmp 某一合法寄存器
jmp ax 在含义上等价于mov IP,ax   
```

 **代码段**

可以将长度为N(N≤64KB)的一组代码，存在一组地址连续、起始地址为 16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段

```css
mov ax,0000		(B8 00 00)
add ax.0123		(05 23 01)
mov bx,ax		(8B D8)
jmp bx			(FF E3)

这段长度为10字节的字节的指令，存在从123B0H~123B9H的一组内存单元中，我们就可以认为，123B0H~123B9H这段内存单元是用来存放代码的，是一个代码段，它的段地址为123BH，长度为10字节
```

CPU只认被CS:IP指向的内存单元中的内容为指令
所以要将CS:IP指向所定义的代码段中的第一条指令的首地址
因此如果要执行这段代码，可设CS = 123BH，IP = 0000H

```CSS
R命令查看、改变CPU寄存器的内容
D命令查看内存中的内容
E命令改写内存中的内容

A命令以汇编指令的格式在内存中写入一条机器指令
U命令将内存中的机器指令翻译成汇编指令
T命令执行一条机器指令

b810:0开始是显存的地址，从这里开始写将会在内存内显示对应的ASCLL码的符号
```

***

# 寄存器(内存访问)

内存中字的存储：CPU用16位寄存器来存储一个字，高8位存放高位字节，低8位存放低位字节

**字单元**：存放一个字型数据(16位)的内存单元，由两个地址连续的内存单元组成，高地址内存单元存放字型数据的高位字节，低地址内存单元存放字型数据的低位字节。

起始地址为N的字单元简称为**N地址字单元**。

任何两个地址连续的内存单元(N号单元和N+1号单元)，既可看成两个内存单元，也可看成一个地址为N的字单元的高位字节单元和低位字节单元

8086PC中，内存地址由段地址和偏移地址组成，**DS**(数据段寄存器)：存放要访问数据的段地址，例如读取10000H单元的内容，可以用如下代码进行：

```css
mov bx,1000H
mov ds,bx
mov al,[0]
```

**8086CPU不支持将数据直接送入段寄存器**，必须通过一般寄存器传入

**[...]表示一个内存单元，[0]表示内存地址的偏移地址为0**

8086CPU是16位结构，有16根数据线，使用16位寄存器就可以进行16位数据的传送

## 指令小结

```CSS
/*mov指令操作对象*/
mov 寄存器,数据||寄存器||段寄存器||内存单元，可传入任何类型
mov 段寄存器,寄存器||内存单元，不可向段寄存器传入数据或段寄存器
mov 内存单元,寄存器||段寄存器，不可向内存单元传入数据或内存单元

/*add指令(sub亦同)操作对象小结*/
add 寄存器,数据||寄存器||内存单元，寄存器不可加上段寄存器
add 不可对段寄存器操作
add 内存单元,寄存器
```

**数据段**

指一组长度为N(N≤64KB)、地址连续、起始地址为16的倍数的内存单元，段地址存放在`ds`段寄存器中

## CPU提供的栈机制

栈是先进后出的数据结构

8086CPU提供入栈和出栈指令

```CSS
push ax
将寄存器ax中的数据送入栈中
pop ax
从栈顶取出数据送入ax
```

8086CPU的入栈和出栈**操作都是以字为单位进行**，**字型数据用两个单元存放，高地址单元放高8位，低地址单元放低8位**

8086CPU中，有两个寄存器：

+ 段寄存器SS：存放栈顶的段地址

+ 寄存器SP：存放栈顶的偏移地址

+ 任意时刻，SS:SP都指向栈顶元素

  当栈为空的时候 ，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元 ，该单元的偏移地址为栈最底部的字单元的偏移地址+2 ，栈最底部字单元的地址为1000:FFFE，栈空时，SP=0000H

**删除元素时不会真的删除，只是标记删除，改变指向，用之后的数据去覆盖**

**栈顶越界问题**

8086CPU不保证对栈的操作不会超界，只知道栈顶在何处（由SS:SP指示），这点就好像CPU只知道当前要执行的指令在何处（由CS:SP指示）而不知道读者要执行的指令有多少

+ 在编程的时候要自己操心栈顶超界的问题 ，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界
+ 执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的超界

**`push`,`pop`指令用法小结:**

- `push (段)寄存器` 将(段)寄存器中的数据入栈
- `pop (段)寄存器` 出栈，用一个(段)寄存器接受出栈的数据
- `push [内存单元的偏移地址]` 将一个内存字单元处的字入栈
- `pop [内存单元的偏移地址]` 出栈，用一个内存字单元接收出栈的数据

push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的

SS、SP指示栈顶，改变SP后写内存的入栈指令，读内存后改变SP的出栈指令

+ `push ax`的具体执行过程：
  1. SP=SP-2，则SS:SP指向当前栈顶前面的单元(新的栈顶)
  2. 将ax中的内容送入SS:SP指向的内存单元处
+ `pop ax`的具体执行过程：
  1. 将SS:SP指向的内存单元处的数据送入ax中 
  2. SP=SP+2，则SS:SP指向当前栈顶下面的单元(新的栈顶)

![image-20240105142606466](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240105142606466.png)

push、pop等栈操作指令修改的只是SP。也就是说，**栈顶的变化范围最大为：0~FFFFH**

**栈段**

可以将长度为N(N ≤64K)的一组地址连续、起始地址为16的倍数的内存单元，当作栈来用，从而定义了一个栈段

用段存放数据就是数据段，用段存放代码就是代码段，用段当作栈就是栈段，在计算机内部都是01，这是逻辑上的区分

+ 数据段：段地址放在`DS`中，用`mov`,`add`,`sub`等访问内存单元的指令时，CPU将数据段中的内容当作数据来访问
+ 代码段：段地址放在`CS`中，将段中第一条指令的偏移地址放在`IP`中，CPU就将执行代码段中的指令
+ 栈段：段地址放在`SS`中，将栈顶单元的偏移地址放在`SP`中，CPU在需要进行栈操作时就将定义的栈段当作栈空间来用

一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是，关键在于CPU中寄存器的设置，即CS、IP、SS、SP、DS的指向

# 编写汇编程序

在汇编语言源程序中包含两种指令

+ **汇编指令**

  有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行

+ **伪指令**

  没有对应的机器码的指令，最终不被CPU所执行，而是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作

`segment`和`ends`是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令

`segment`和`ends`的功能是定义一个段，`segment`说明一个段开始，`ends`说明一个段结束

一个段必须有一个名称来标识，使用格式为：

```CSS
段名 segment
	
段名 ends
```

一个汇编程序是由多个段组成，这些段被用来存放代码、数据或当作栈空间来使用

+ `end`是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令`end`，就结束对源程序的编译

+ `assume`假设某一段寄存器和程序中的某一个用 segment … ends 定义的段相关联

  通过`assume`说明这种关联，在需要的情况下 ，编译程序可以将段寄存器和某一个具体的段相联系

**程序经编译连接后变为机器码**

+ 编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件

+ 连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件

将源程序文件中的所有内容称为源程序，将源程序中最终由计算机执行处理的指令或数据 ，成为程序

一个标号指代了一个地址

+ `codesg`：放在`segment`的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址

```cSS
    /*计算2的3次方*/
	assume cs:abc
    abc segment
       mov ax,2
       add ax,ax
       add ax,ax
	  /*程序返回指令*/
	   mov ax,4c00H
       int 21H

    abc ends
    end
```

一个程序结束后，将CPU的控制权交还给使它得以运行的程序，我们称这个过程为程序返回
